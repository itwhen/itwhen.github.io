---
title: DataSource -
---
//[echo](../../index.md)/[tech.whence.echo.support.kafka.receiver](../index.md)/[DataSource](index.md)



# DataSource  
 [jvm] 

数据源

class [DataSource](index.md) : [AbstractDataSource](../../tech.whence.echo.support.kafka/-abstract-data-source/index.md)   


## Constructors  
  
|  Name|  Summary| 
|---|---|
| [DataSource](-data-source.md)|  [jvm] fun [DataSource](-data-source.md)()   <br>


## Functions  
  
|  Name|  Summary| 
|---|---|
| [equals](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/equals/#kotlin.Any?/PointingToDeclaration/)| [jvm]  <br>Content  <br>open operator override fun [equals](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/equals/#kotlin.Any?/PointingToDeclaration/)(other: [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)?): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)  <br><br><br>
| [hashCode](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/hashCode/#/PointingToDeclaration/)| [jvm]  <br>Content  <br>open override fun [hashCode](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/hashCode/#/PointingToDeclaration/)(): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)  <br><br><br>
| [toString](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/toString/#/PointingToDeclaration/)| [jvm]  <br>Content  <br>open override fun [toString](../../tech.whence.echo.webclient.response.exception/-response-unrecognized-exception/index.md#kotlin/Any/toString/#/PointingToDeclaration/)(): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)  <br><br><br>


## Properties  
  
|  Name|  Summary| 
|---|---|
| [autoCommitIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/autoCommitIntervalMs/#/PointingToDeclaration/)|  [jvm] <br><br>如果 enable.auto.commit 设置为true，消费者偏移量自动提交给Kafka的频率（以毫秒为单位）<br><br>var [autoCommitIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/autoCommitIntervalMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [autoOffsetReset](index.md#tech.whence.echo.support.kafka.receiver/DataSource/autoOffsetReset/#/PointingToDeclaration/)|  [jvm] <br><br>如果Kafka没有初始偏移量，或当前偏移量在服务器上不存在（例如，因为该数据已被删除），那么该怎么办： earliest：将偏移量自动重置为最早的偏移量 latest：自动将偏移量重置为最新的偏移量 none：如果没有找到消费者组的以前的偏移量，则将异常抛出给消费者 其他任何东西：将异常抛出给消费者。<br><br>var [autoOffsetReset](index.md#tech.whence.echo.support.kafka.receiver/DataSource/autoOffsetReset/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [checkCrcs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/checkCrcs/#/PointingToDeclaration/)|  [jvm] <br><br>自动检查CRC32记录的消耗。 这样可以确保消息发生时不会在线或磁盘损坏。 此检查会增加一些开销，因此在寻求极致性能的情况下可能会被禁用。<br><br>var [checkCrcs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/checkCrcs/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [clientId](index.md#tech.whence.echo.support.kafka.receiver/DataSource/clientId/#/PointingToDeclaration/)|  [jvm] <br><br>当向server发出请求时 这个字符串会发送给server 目的是能够追踪请求源头，以此来允许ip/port许可列表之外的一些应用可以发送信息 这项应用可以设置任意字符串，因为没有任何功能性的目的，除了记录和跟踪<br><br>override var [clientId](index.md#tech.whence.echo.support.kafka.receiver/DataSource/clientId/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [connections](index.md#tech.whence.echo.support.kafka.receiver/DataSource/connections/#/PointingToDeclaration/)|  [jvm] <br><br>用于建立与kafka集群连接的host/port组 数据将会在所有servers上均衡加载 不管哪些server是指定用于bootstrapping 这个列表仅仅影响初始化的hosts（用于发现全部的servers） 这个列表格式: host1:port1,host2:port2,... 因为这些server仅仅是用于初始化的连接，以发现集群所有成员关系（可能会动态的变化），这个列表不需要包含所有的servers（你可能想要不止一个server，尽管这样，可能某个server宕机了） 如果没有server在这个列表出现，则发送数据会一直失败，直到列表可用。<br><br>override var [connections](index.md#tech.whence.echo.support.kafka.receiver/DataSource/connections/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [connectionsMaxIdleMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/connectionsMaxIdleMs/#/PointingToDeclaration/)|  [jvm] <br><br>关闭连接空闲时间<br><br>override var [connectionsMaxIdleMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/connectionsMaxIdleMs/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [enableAutoCommit](index.md#tech.whence.echo.support.kafka.receiver/DataSource/enableAutoCommit/#/PointingToDeclaration/)|  [jvm] <br><br>如果为真，消费者的偏移量将在后台定期提交。<br><br>var [enableAutoCommit](index.md#tech.whence.echo.support.kafka.receiver/DataSource/enableAutoCommit/#/PointingToDeclaration/): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)?   <br>
| [excludeInternalTopics](index.md#tech.whence.echo.support.kafka.receiver/DataSource/excludeInternalTopics/#/PointingToDeclaration/)|  [jvm] <br><br>来自内部主题的记录（如偏移量）是否应该暴露给消费者。 如果设置为 true，则从内部主题接收记录的唯一方法是订阅。<br><br>var [excludeInternalTopics](index.md#tech.whence.echo.support.kafka.receiver/DataSource/excludeInternalTopics/#/PointingToDeclaration/): [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)?   <br>
| [fetchMaxBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMaxBytes/#/PointingToDeclaration/)|  [jvm] <br><br>服务器为获取请求返回的最大数据量。 这不是一个绝对最大值，如果第一个非空分区的fetch中的第一条消息大于此值，则该消息仍将被返回以确保消费者可以进行进度。 代理接受的最大消息大小是通过 message.max.bytes （broker config）或 max.message.bytes（topic config）定义的。 请注意，消费者并行执行多个提取。<br><br>var [fetchMaxBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMaxBytes/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [fetchMaxWaitMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMaxWaitMs/#/PointingToDeclaration/)|  [jvm] <br><br>如果没有足够的数据来满足fetch.min.bytes所要求的要求，服务器将在接收到提取请求之前阻止的最长时间。<br><br>var [fetchMaxWaitMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMaxWaitMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [fetchMinBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMinBytes/#/PointingToDeclaration/)|  [jvm] <br><br>服务器应该为获取请求返回的最小数据量。 如果没有足够的数据可用，请求将等待这么多数据累积才能回答请求。 1字节的默认设置意味着只要单个字节的数据可用或提取请求超时才能等待数据到达，则提取请求将被应答。 将其设置为大于1将导致服务器等待更大量的数据累积，这可能会以一些额外的延迟为代价来提高服务器吞吐量。<br><br>var [fetchMinBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/fetchMinBytes/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [groupId](index.md#tech.whence.echo.support.kafka.receiver/DataSource/groupId/#/PointingToDeclaration/)|  [jvm] <br><br>用来唯一标识consumer进程所在组的字符串， 如果设置同样的group id，表示这些processes都是属于同一个consumer group<br><br>var [groupId](index.md#tech.whence.echo.support.kafka.receiver/DataSource/groupId/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [heartbeatIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/heartbeatIntervalMs/#/PointingToDeclaration/)|  [jvm] <br><br>使用Kafka组管理时，心跳与消费者协调员之间的预期时间。 心跳用于确保消费者的会话保持活动，并在新消费者加入或离开组时促进重新平衡。 该值必须设置为低于session.timeout.ms  code>，但通常应设置为不高于该值的1/3。 它可以调整得更低，以控制正常重新平衡的预期时间。<br><br>var [heartbeatIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/heartbeatIntervalMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [maxPartitionFetchBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPartitionFetchBytes/#/PointingToDeclaration/)|  [jvm] <br><br>服务器将返回的每个分区的最大数据量。 如果fetch的第一个非空分区中的第一个消息大于此限制，则仍将返回消息，以确保消费者可以进行进度。 代理接受的最大消息大小是通过 message.max.bytes（broker config）或 max.message.bytes（topic config）定义的。<br><br>var [maxPartitionFetchBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPartitionFetchBytes/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [maxPollIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPollIntervalMs/#/PointingToDeclaration/)|  [jvm] <br><br>在使用消费者组管理时调用poll（）的最大延迟。 这在获取更多记录之前将消费者空闲时间的上限置于上限之内。 如果在此超时到期之前未调用poll（），则消费者被认为失败，并且该组将重新平衡，以便将分区重新分配给另一个成员。<br><br>var [maxPollIntervalMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPollIntervalMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [maxPollRecords](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPollRecords/#/PointingToDeclaration/)|  [jvm] <br><br>在单次调用poll()中返回的最大记录数<br><br>var [maxPollRecords](index.md#tech.whence.echo.support.kafka.receiver/DataSource/maxPollRecords/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [metadataMaxAgeMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/metadataMaxAgeMs/#/PointingToDeclaration/)|  [jvm] <br><br>以毫秒为单位的时间，是在我们强制更新metadata的时间间隔。 即使我们没有看到任何partition leadership改变。<br><br>override var [metadataMaxAgeMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/metadataMaxAgeMs/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [partitionAssignmentStrategy](index.md#tech.whence.echo.support.kafka.receiver/DataSource/partitionAssignmentStrategy/#/PointingToDeclaration/)|  [jvm] <br><br>分组分配策略的类名称，当使用组管理时，客户端将用于在消费者实例之间分配分区所有权<br><br>var [partitionAssignmentStrategy](index.md#tech.whence.echo.support.kafka.receiver/DataSource/partitionAssignmentStrategy/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [receiveBufferBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/receiveBufferBytes/#/PointingToDeclaration/)|  [jvm] <br><br>TCP的接收缓存 SO_RCVBUF 空间大小 用于读取数据<br><br>override var [receiveBufferBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/receiveBufferBytes/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [reconnectBackoffMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/reconnectBackoffMs/#/PointingToDeclaration/)|  [jvm] <br><br>连接失败重新连接时的等待时间<br><br>override var [reconnectBackoffMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/reconnectBackoffMs/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [requestTimeoutMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/requestTimeoutMs/#/PointingToDeclaration/)|  [jvm] <br><br>客户端将等待请求的响应的最大时间,如果在这个时间内没有收到响应，客户端将重发请求;超过重试次数将抛异常<br><br>override var [requestTimeoutMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/requestTimeoutMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>
| [retryBackoffMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/retryBackoffMs/#/PointingToDeclaration/)|  [jvm] <br><br>在重试发送失败的request前的等待时间 防止若目的Broker完全挂掉的情况下Producer一直陷入死循环发送 折中的方法<br><br>override var [retryBackoffMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/retryBackoffMs/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [sendBufferBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/sendBufferBytes/#/PointingToDeclaration/)|  [jvm] <br><br>TCP的发送缓存 SO_SNDBUF 空间大小 用于发送数据<br><br>override var [sendBufferBytes](index.md#tech.whence.echo.support.kafka.receiver/DataSource/sendBufferBytes/#/PointingToDeclaration/): [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)?   <br>
| [sessionTimeoutMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/sessionTimeoutMs/#/PointingToDeclaration/)|  [jvm] <br><br>用于在使用Kafka的组管理工具时检测消费者失败的超时时间。 消费者定期发送心跳以指示其对经纪人的活力。 如果在此会话超时到期之前，代理没有收到心跳，那么代理将从组中删除该消费者并启动重新平衡。 请注意，该值必须在代码配置中由 group.min.session.timeout.ms 和 group.max.session.timeout.ms 中配置的允许范围内。<br><br>var [sessionTimeoutMs](index.md#tech.whence.echo.support.kafka.receiver/DataSource/sessionTimeoutMs/#/PointingToDeclaration/): [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)?   <br>

